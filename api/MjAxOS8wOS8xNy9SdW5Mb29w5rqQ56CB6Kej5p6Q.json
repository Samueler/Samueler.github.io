{"title":"RunLoop源码解析","date":"2019-09-17T07:08:23.846Z","link":"2019/09/17/RunLoop源码解析","comments":true,"updated":"2019-09-18T10:01:21.379Z","content":"<h4 id=\"CHECK-FOR-FORK-函数与Fork函数解析\"><code>CHECK_FOR_FORK()</code>函数与<code>Fork</code>函数解析:<a href=\"2019/09/17/RunLoop源码解析#CHECK-FOR-FORK-函数与Fork函数解析\"></a></h4><p>为什么要提前了解<code>CHECK_FOR_FORK()</code>函数？因为在阅读<code>CFRunLoop</code>源码中，很多方法的实现都调用了该方法。</p>\n<h5 id=\"Fork函数解析-wiki-Fork\"><code>Fork</code>函数解析:<a href=\"https://zh.wikipedia.org/wiki/Fork_(%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)\" target=\"_blank\" rel=\"noopener\">wiki: Fork</a><a href=\"2019/09/17/RunLoop源码解析#Fork函数解析-wiki-Fork\"></a></h5><h6 id=\"wiki重点内容摘抄：\">wiki重点内容摘抄：<a href=\"2019/09/17/RunLoop源码解析#wiki重点内容摘抄：\"></a></h6><p>如果进程需要启动另一个程序的可执行文件，它需要fork来创建一个自身的副本。然后由该副本即”子进程”调用<code>exec</code>。<br><code>Fork</code>操作会为子进程创建一个单独的地址空间。子进程拥有父进程所有内存段的精确副本。在现代UNIX变种中，物理内存不需要被实际复制，而是通过<code>写时复制</code>。两个进程的虚拟内存页面可能指向物理内存中的同一个页，知道它们写入该页时，写入才会发生。</p>\n<p>当一个进程调用fork时，它被认为是父进程，新创建的进程是它的子进程。在fork之后，两个进程运行着相同的程序，然后它们可以检查调用的返回值确定其状态：是父进程还是子进程，然后各自行事。</p>\n<p>fork函数示例:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, const char * argv[]) {\n\n    pid_t pid = fork();\n\n    if (pid &lt; 0) {\n        perror(&quot;fork failed&quot;);\n    } else if (pid == 0) {\n        printf(&quot;This is a child process.Current PID:%d, father PID:%d, child PID:%D\\n&quot;, getpid(), getppid(), pid);\n    } else {\n        printf(&quot;This is a father process.Current PID:%d, child PID:%d\\n&quot;, getpid(), pid);\n    }\n\n    return 0;\n}</code></pre><p>打印结果：</p>\n<pre><code>This is a father process.\nCurrent PID:12946, child PID:12948\nThis is a child process.Current \nPID:12948, father PID:12946, child PID:0\nProgram ended with exit code: 0</code></pre><p><code>fork</code>函数返回值：</p>\n<p>1.返回值小于0，fork出错</p>\n<p>(a).当前进程数已经达到系统规定最大值，这是errno的值被设为EAGAIN</p>\n<p>(b).系统内存不足，这时errno的值被设置为ENOMEM</p>\n<p>2.返回值为0<br>该进程为子进程，子进程使用<code>getpid()</code>获取当前进程，使用<code>getppid()</code>获取父进程</p>\n<p>3.返回值大于0<br>该进程为父进程，当前进程的值为子进程的PID</p>\n<p>查看<code>CHECK_FOR_FORK()</code>函数的定义：</p>\n<pre><code>#define CHECK_FOR_FORK() do { \n    __CF120290 = true; \n    if (__CF120293) __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__(); \n} while (0)</code></pre><p>搜索源码中<strong>CF120290变量和</strong>CF120293变量相关代码，可发现下面函数的定义与实现。</p>\n<pre><code>static void __01121__(void) {\n    __CF120291 = pthread_is_threaded_np() ? true : false;\n}\n\nstatic void __01123__(void) {\n    // Ideally, child-side atfork handlers should be async-cancel-safe, as fork()\n    // is async-cancel-safe and can be called from signal handlers.  See also\n    // http://standards.ieee.org/reading/ieee/interp/1003-1c-95_int/pasc-1003.1c-37.html\n    // This is not a problem for CF.\n    if (__CF120290) {\n    __CF120293 = true;\n#if DEPLOYMENT_TARGET_MACOSX\n    if (__CF120291) {\n        CRSetCrashLogMessage2(&quot;*** multi-threaded process forked ***&quot;);\n    } else {\n        CRSetCrashLogMessage2(&quot;*** single-threaded process forked ***&quot;);\n    }\n#endif\n    }\n}</code></pre><p>在<code>CFRuntime.c</code>中找到<code>__CFInitialize</code>函数并发现代码段<code>pthread_atfork(__01121__, NULL, __01123__);</code></p>\n<h4 id=\"pthread-atfork函数解析\"><code>pthread_atfork</code>函数解析<a href=\"2019/09/17/RunLoop源码解析#pthread-atfork函数解析\"></a></h4><p><code>pthread_atfork</code>的函数声明如下：</p>\n<pre><code>int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</code></pre><p><code>pthread_atfork()</code>在<code>fork</code>函数之前调用，当调用fork时，内部创建子进程前在父进程中会调用prepare，内部创建子进程成功后，父进程会调用parent，子进程会调用child。</p>\n<p>因此，在初始化runtime时，未创建子进程成功前，先调用函数<code>__01121__</code>函数，设置<code>__CF120291</code>的值，如果当前线程是主线程，那么<code>__CF120291</code>的值为true，否则为false。当创建子进程成功后，则会调用<code>__01123__</code>函数，在<code>__01123__</code>函数中，当<code>__CF120290</code>的值为true时，设置<code>__CF120293</code>的值为true。</p>\n<p>当调用<code>CHECK_FOR_FORK</code>函数时，如果此时成功创建子进程，那么会调用<code>__01123__</code>函数，使<code>__CF120293</code>为true，则进入条件并调用<code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</code>方法。</p>\n<p><code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</code>方法实现如下：</p>\n<pre><code>#define EXEC_WARNING_STRING_1 &quot;The process has forked and you cannot use this CoreFoundation functionality safely. You MUST exec().\\n&quot;\n#define EXEC_WARNING_STRING_2 &quot;Break on __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__() to debug.\\n&quot;\n\nCF_PRIVATE void __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__(void) {\n    write(2, EXEC_WARNING_STRING_1, sizeof(EXEC_WARNING_STRING_1) - 1);\n    write(2, EXEC_WARNING_STRING_2, sizeof(EXEC_WARNING_STRING_2) - 1);\n//    HALT;\n}</code></pre><p>由代码可以清晰看出<code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</code>函数只是将相关报错信息写入到文件中。类似于日志的作用。</p>\n<p>在<code>CFRunLoop.h</code>中我们只能找到两个获取runloop的函数:</p>\n<pre><code>CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);\nCF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);</code></pre><p>进入<code>CFRunloop.c</code>文件中查看对应的方法实现：</p>\n<pre><code>CFRunLoopRef CFRunLoopGetMain(void) {\n    CHECK_FOR_FORK();\n    static CFRunLoopRef __main = NULL; // no retain needed\n    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed\n    return __main;\n}\n\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}</code></pre><p>在两个函数的实现中，可以看到<code>CHECK_FOR_FORK</code>函数的调用，判断子进程是否创建成功。并且在没有runLoop的条件下调用了<code>_CFRunLoopGet0()</code>函数，并将对应的线程作为实参。下面就对<code>_CFRunLoopGet0</code>函数进行分析。</p>\n<h4 id=\"CFRunLoopGet-pthread-t-thread\"><code>_CFRunLoopGet(pthread_t thread)</code><a href=\"2019/09/17/RunLoop源码解析#CFRunLoopGet-pthread-t-thread\"></a></h4><pre><code>static CFMutableDictionaryRef __CFRunLoops = NULL;\nstatic CFLock_t loopsLock = CFLockInit;\n\n// should only be called by Foundation\n// t==0 is a synonym for &quot;main thread&quot; that always works\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n    // 线程t为空，赋值t为主线程\n    if (pthread_equal(t, kNilPthreadT)) {\n        t = pthread_main_thread_np();\n    }\n\n    // 使用互斥锁加锁\n    __CFLock(&amp;loopsLock);\n    if (!__CFRunLoops) { // 查看__CFRunLoops是否为空,__CFRunLoops是一个字典\n        __CFUnlock(&amp;loopsLock); // 解锁\n    // 创建一个可变字典 kCFTypeDictionaryValueCallBacks 是一个结构体\n    // 结构体中的属性是一些函数指针\n    // const CFDictionaryCallBacks kCFTypeDictionaryCallBacks = {0, __CFTypeCollectionRetain, __CFTypeCollectionRelease, CFCopyDescription, CFEqual, CFHash};\n    // __CFTypeCollectionRetain等值均为再CFRuntime.c中实现的函数\n    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);\n    // 创建主线程的runLoop\n    CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n    // 将主线程的线程指针作为key，mainLoop为value，存储在dict字典中\n    CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);\n    // 如果__CFRunLoops为null，那么将dict赋值给__CFRunLoops，否则释放dict\n    if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) {\n        CFRelease(dict);\n    }\n    // 释放mainLoop\n    CFRelease(mainLoop);\n        __CFLock(&amp;loopsLock);\n    }\n    // 从字典__CFRunLoops中获取t线程指针为key的loop\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    __CFUnlock(&amp;loopsLock);\n    // 如果没有loop,创建t线程的loop,并该loop存储至__CFRunLoops字典中\n    if (!loop) {\n        CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n        __CFLock(&amp;loopsLock);\n        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n        if (!loop) {\n            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n            loop = newLoop;\n    }\n    // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n    __CFUnlock(&amp;loopsLock);\n    CFRelease(newLoop);\n}\n    // 如果当前线程和t线程是统一线程\n    if (pthread_equal(t, pthread_self())) {\n        // 设置线程私有数据TSD（thread specifical data）\n        // Windows and Linux have created the table already, we need to \n        // initialize it here for other platforms. On Windows, the cleanup\n        // function is called by DllMain when a thread exits. On \n        // Linux the destructor is set at init time.            \n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n        }\n    }\n    return loop;\n}</code></pre><p>获取指定线程runLoop的大致流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2373648-e383c2a487c8bbaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024\" alt></p>\n<h5 id=\"细节分析\">细节分析:<a href=\"2019/09/17/RunLoop源码解析#细节分析\"></a></h5><h6 id=\"OSAtomicCompareAndSwapPtrBarrier函数\"><code>OSAtomicCompareAndSwapPtrBarrier</code>函数<a href=\"2019/09/17/RunLoop源码解析#OSAtomicCompareAndSwapPtrBarrier函数\"></a></h6><pre><code>bool OSAtomicCompareAndSwapPtrBarrier(void *oldp, void *newp, void *volatile *dst);\nCF_EXPORT bool OSAtomicCompareAndSwapPtrBarrier(void *oldp, void *newp, void *volatile *dst)\n{\n   // 第一个参数与第三个参数如果相等，那么第二个参数的值与第一个参数的值互换 InterlockedCompareExchangePointer：互锁函数之一\n    return oldp == InterlockedCompareExchangePointer(dst, newp, oldp);\n}</code></pre><p>原子操作可查看资料<a href=\"http://southpeak.github.io/2014/10/17/osatomic-operation/\" target=\"_blank\" rel=\"noopener\">OSAtomic原子操作</a>。</p>\n<h6 id=\"CFSetTSD函数\"><code>_CFSetTSD</code>函数<a href=\"2019/09/17/RunLoop源码解析#CFSetTSD函数\"></a></h6><pre><code>// For the use of CF and Foundation only\nCF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, tsdDestructor destructor) {\n    if (slot &gt; CF_TSD_MAX_SLOTS) {\n        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (set)&quot;, slot);\n        HALT;\n    }\n     __CFTSDTable *table = __CFTSDGetTable();\n    if (!table) {\n        // Someone is setting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.\n        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d set but the thread data has already been torn down.&quot;, slot);\n        return NULL;\n    }\n    void *oldVal = (void *)table-&gt;data[slot];\n\n    table-&gt;data[slot] = (uintptr_t)newVal;\n    table-&gt;destructors[slot] = destructor;\n\n    return oldVal;\n}</code></pre><h4 id=\"TSD-Thread-Specific-Data-：线程私有数据\">TSD(Thread Specific Data)：线程私有数据<a href=\"2019/09/17/RunLoop源码解析#TSD-Thread-Specific-Data-：线程私有数据\"></a></h4><h6 id=\"摘抄：\">摘抄：<a href=\"2019/09/17/RunLoop源码解析#摘抄：\"></a></h6><p>在多线程环境下，进程内的所有线程共享进程的数据空间，因此全局变量为所有线程共有。在程序设计中有时需要保存线程自己的全局变量，这种特殊的变量仅在某个线程内部有效。如常见的变量errno，它返回标准的出错代码。errno不应该是一个局部变量，几乎每个函数都应该可以访问它；但它又不能作为一个全局变量，否则在一个线程里输出的很可能是另一个线程的出错信息，这个问题可以通过创建多线程的私有数据（TSD）来解决。在线程内部，线程私有数据可以被各个函数访问，但它对其他线程是屏蔽的。</p>\n<p>线程私有数据采用了一种被称为一键多值的技术，即一个键对应多个数组。访问数据时都是通过键值来访问，好像是对一个变量进行访问，其实是再访问不同的数据。使用线程私有数据时，首先要为每个线程数据创建一个相关联的键。在各个线程内部，都使用这个公用的键来指代线程数据，但是，在不同的线程中，这个键代表的数据时不同的。操作线程私有数据的函数主要有4个；<code>pthread_key_create</code>创建一个键,<code>pthread_setspecific</code>为一个键设置线程私有数据,<code>pthread_getspecific</code>从一个键读取线程私有数据,<code>pthread_key_delete</code>删除一个键。</p>\n<pre><code>// Set some thread specific data in a pre-assigned\n// slot. Don&apos;t pick a random value. Make sure you&apos;re\n// using a slot that is unique. Pass in a destructor\n// to free this data, or NULL if none is needed. \n// Unlike pthread TSD, the destructor is per-thread.\nCF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, void (*destructor)(void *));</code></pre><p>首先我们从源码中找到<code>_CFSetTSD</code>函数的声明，看到对应注释，翻译过来的意思大致如下：</p>\n<p>在预先指定的点位中设置线程私有数据。需要保证使用的点位的值唯一的，不能使用随机数值。如果需要释放对应的data，那么需要传入一个不为NULL的析构函数，如果不需要进行释放，则直接传入NULL。与pthread TSD不同的是，此析构函数是每个线程都有的。</p>\n<p>查阅<code>_CFSetTSD</code>函数的具体实现，可以看到传入的<code>newVal</code>是被保存在<code>__CFTSDTable</code>的<code>data</code>数组中的。</p>\n<h6 id=\"CFTSDTable结构体\"><code>__CFTSDTable</code>结构体<a href=\"2019/09/17/RunLoop源码解析#CFTSDTable结构体\"></a></h6><pre><code>typedef struct __CFTSDTable {\n    uint32_t destructorCount;\n    uintptr_t data[CF_TSD_MAX_SLOTS];\n    tsdDestructor destructors[CF_TSD_MAX_SLOTS];\n} __CFTSDTable;</code></pre><p><code>__CFTSDTable</code>的属性较为简单。<code>destructorCount</code>存储了析构函数的数量;<code>data</code>存储数据的数组，其中<code>CF_TSD_MAX_SLOTS</code>为70;<code>destructors</code>存储析构函数的数组。</p>\n<p>获取<code>__CFTSDTable</code>使用<code>__CFTSDGetTable</code>函数。</p>\n<pre><code>// Get or initialize a thread local storage. It is created on demand.\nstatic __CFTSDTable *__CFTSDGetTable() {\n    __CFTSDTable *table = (__CFTSDTable *)__CFTSDGetSpecific();\n    // Make sure we&apos;re not setting data again after destruction.\n    if (table == CF_TSD_BAD_PTR) {\n        return NULL;\n    }\n    // Create table on demand\n    if (!table) {\n        // This memory is freed in the finalize function\n        table = (__CFTSDTable *)calloc(1, sizeof(__CFTSDTable));\n        #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n            pthread_key_init_np(CF_TSD_KEY, __CFTSDFinalize);\n        #endif\n         __CFTSDSetSpecific(table);\n    }\n    return table;\n}</code></pre><p>通过<code>__CFTSDGetSpecific</code>函数获取指定key下的table，在不同平台使用不同的方法和key获取table。具体如下:</p>\n<pre><code>static void *__CFTSDGetSpecific() {\n    #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n        return _pthread_getspecific_direct(CF_TSD_KEY);\n    #elif DEPLOYMENT_TARGET_LINUX\n        return pthread_getspecific(__CFTSDIndexKey);\n    #elif DEPLOYMENT_TARGET_WINDOWS\n        return TlsGetValue(__CFTSDIndexKey);\n    #endif\n}</code></pre><p>在没有获取table的情况下，分配内存创建table，并通过函数<code>__CFTSDSetSpecific</code>在不同平台使用不同的key来设置TSD。最后返回创建好的table。</p>\n<pre><code>static void __CFTSDSetSpecific(void *arg) {\n    #if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI\n           _pthread_setspecific_direct(CF_TSD_KEY, arg);\n    #elif DEPLOYMENT_TARGET_LINUX\n        pthread_setspecific(__CFTSDIndexKey, arg);\n    #elif DEPLOYMENT_TARGET_WINDOWS\n        TlsSetValue(__CFTSDIndexKey, arg);\n    #endif\n}</code></pre><p>回到<code>_CFRunLoopGet(pthread_t thread)</code>函数中的最后几行。</p>\n<pre><code>if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {\n    _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);\n}</code></pre><p>获取<code>__CFTSDKeyRunLoopCntr</code>点位的TSD，如果没有的话，则设置<code>__CFTSDKeyRunLoopCntr</code>点位的TSD，并传入对应的析构函数<code>__CFFinalizeRunLoop</code>，因此当当线程销毁时，runLoop紧跟着销毁。</p>\n<pre><code>// For the use of CF and Foundation only\nCF_EXPORT void *_CFGetTSD(uint32_t slot) {\n    if (slot &gt; CF_TSD_MAX_SLOTS) {\n        _CFLogSimple(kCFLogLevelError, &quot;Error: TSD slot %d out of range (get)&quot;, slot);\n        HALT;\n    }\n    __CFTSDTable *table = __CFTSDGetTable();\n    if (!table) {\n        // Someone is getting TSD during thread destruction. The table is gone, so we can&apos;t get any data anymore.\n        _CFLogSimple(kCFLogLevelWarning, &quot;Warning: TSD slot %d retrieved but the thread data has already been torn down.&quot;, slot);\n        return NULL;\n    }\n    uintptr_t *slots = (uintptr_t *)(table-&gt;data);\n    return (void *)slots[slot];\n}</code></pre><p>由析构函数``我们可以看到，线程销毁时，内部是通过遍历slot逐一销毁的。</p>\n<pre><code>static void __CFTSDFinalize(void *arg) {\n    // Set our TSD so we&apos;re called again by pthreads. It will call the destructor PTHREAD_DESTRUCTOR_ITERATIONS times as long as a value is set in the thread specific data. We handle each case below.\n    __CFTSDSetSpecific(arg);\n\n    if (!arg || arg == CF_TSD_BAD_PTR) {\n        // We&apos;ve already been destroyed. The call above set the bad pointer again. Now we just return.\n        return;\n    }\n\n    __CFTSDTable *table = (__CFTSDTable *)arg;\n    table-&gt;destructorCount++;\n\n    // On first calls invoke destructor. Later we destroy the data.\n    // Note that invocation of the destructor may cause a value to be set again in the per-thread data slots. The destructor count and destructors are preserved.  \n    // This logic is basically the same as what pthreads does. We just skip the &apos;created&apos; flag.\n    for (int32_t i = 0; i &lt; CF_TSD_MAX_SLOTS; i++) {\n        if (table-&gt;data[i] &amp;&amp; table-&gt;destructors[i]) {\n            uintptr_t old = table-&gt;data[i];\n            table-&gt;data[i] = (uintptr_t)NULL;\n            table-&gt;destructors[i]((void *)(old));\n        }\n    }\n\n    if (table-&gt;destructorCount == PTHREAD_DESTRUCTOR_ITERATIONS - 1) {    // On PTHREAD_DESTRUCTOR_ITERATIONS-1 call, destroy our data\n        free(table);\n\n        // Now if the destructor is called again we will take the shortcut at the beginning of this function.\n        __CFTSDSetSpecific(CF_TSD_BAD_PTR);\n        return;\n    }\n}</code></pre><p>查看枚举我们便能知道相应类型销毁的顺序。例如<code>AutoreleasePool</code>是要比<code>RunLoop</code>后的</p>\n<pre><code>// Foundation uses 20-40\n// Foundation knows about the value of __CFTSDKeyAutoreleaseData1\nenum {\n    __CFTSDKeyAllocator = 1,\n    __CFTSDKeyIsInCFLog = 2,\n    __CFTSDKeyIsInNSCache = 3,\n    __CFTSDKeyIsInGCDMainQ = 4,\n    __CFTSDKeyICUConverter = 7,\n    __CFTSDKeyCollatorLocale = 8,\n    __CFTSDKeyCollatorUCollator = 9,\n    __CFTSDKeyRunLoop = 10,\n    __CFTSDKeyRunLoopCntr = 11,\n    __CFTSDKeyMachMessageBoost = 12, // valid only in the context of a CFMachPort callout\n    __CFTSDKeyMachMessageHasVoucher = 13,\n    // autorelease pool stuff must be higher than run loop constants\n    __CFTSDKeyAutoreleaseData2 = 61,\n    __CFTSDKeyAutoreleaseData1 = 62,\n    __CFTSDKeyExceptionData = 63,\n};</code></pre><p>最后返回相应的runLoop。</p>\n<p>在上面我们说了一大段如何获取指定线程的runLoop，那runLoop到底是什么样的结构呢？我们还是根据源码的定义去一探究竟。</p>\n<pre><code>typedef struct __CFRunLoop * CFRunLoopRef;\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;            /* locked for accessing mode list */\n    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFAbsoluteTime _runTime;\n    CFAbsoluteTime _sleepTime;\n    CFTypeRef _counterpart;\n};</code></pre><p>runLoop其实就是一个结构体，里面有一些描述它的一些属性，我们对这些属性一一解释：</p>\n<p><code>CFRuntimeBase _base</code></p>\n<h6 id=\"CFRuntimeBase结构体：\"><code>CFRuntimeBase</code>结构体：<a href=\"2019/09/17/RunLoop源码解析#CFRuntimeBase结构体：\"></a></h6><pre><code>/* All CF &quot;instances&quot; start with this structure.  Never refer to\n * these fields directly -- they are for CF&apos;s use and may be added\n * to or removed or change format without warning.  Binary\n * compatibility for uses of this struct is not guaranteed from\n * release to release.\n */\ntypedef struct __CFRuntimeBase {\n    uintptr_t _cfisa;\n    uint8_t _cfinfo[4];\n#if __LP64__\n    uint32_t _rc;\n#endif\n} CFRuntimeBase;</code></pre><p>在获取对应线程runLoop的过程中，其中有个过程是创建runLoop，接下来我们来看下runLoop到底是如何创建的。</p>\n","plink":"http://yoursite.com/2019/09/17/RunLoop源码解析/"}