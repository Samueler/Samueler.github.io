{"title":"iOS组件化-资源管理","date":"2019-12-17T04:07:08.258Z","link":"2019/12/17/iOS组件化-资源管理","comments":true,"updated":"2019-12-19T01:20:56.326Z","content":"<p>在组件化前期的工作中，我们会面临如何管理图片、音视频等资源的问题。我们需要关注的问题是如何将相应的资源和组件一起打包，并保证能够在组件内和组件间的正常使用。以下内容均针对于使用<code>CocoaPods</code>方式组件化对资源文件管理的讨论。</p>\n<h4 id=\"文件管理方式：\">文件管理方式：<a href=\"2019/12/17/iOS组件化-资源管理#文件管理方式：\"></a></h4><h5 id=\"1-集中式管理\">1. 集中式管理<a href=\"2019/12/17/iOS组件化-资源管理#1-集中式管理\"></a></h5><p>将所有的资源文件做成一个组件，其它相应的组件依赖该资源组件，通过组件暴露的相关接口获取对应的资源。</p>\n<h5 id=\"2-分散式管理\">2.    分散式管理<a href=\"2019/12/17/iOS组件化-资源管理#2-分散式管理\"></a></h5><p>将资源文件进行清晰分类，对应的资源文件嵌入至对应的组件中，如有共用文件，抽取公共资源组件将公共资源放入该组件中，或者将公共资源直接放至主工程中。</p>\n<h5 id=\"集中式管理与分散式管理优缺点对比：\">集中式管理与分散式管理优缺点对比：<a href=\"2019/12/17/iOS组件化-资源管理#集中式管理与分散式管理优缺点对比：\"></a></h5><img src=\"/2019/12/17/iOS组件化-资源管理/1.png\" class=\"article-img\">\n\n<h5 id=\"总结建议：\">总结建议：<a href=\"2019/12/17/iOS组件化-资源管理#总结建议：\"></a></h5><p>集中式管理可方便维护，可对项目文件进行统一管理，此外还可降低文件冗余的概率，可用于较大、耦合严重的项目。倘若是新项目或者组件对主工程依赖性不强的组件，可采用分散式管理，将组件的相关资源与组件绑定。</p>\n<h3 id=\"resources和resource-bundles\"><code>resources</code>和<code>resource_bundles</code><a href=\"2019/12/17/iOS组件化-资源管理#resources和resource-bundles\"></a></h3><p><code>resoures</code>和<code>resource_bundles</code>是<code>CocoaPods</code>两种资源文件引用的方式。</p>\n<h4 id=\"1-resource-resources\">1. <code>resource/resources</code><a href=\"2019/12/17/iOS组件化-资源管理#1-resource-resources\"></a></h4><p><code>resource</code>与<code>resources</code>两个属性功能相同，不同的是<code>resources</code>可以批量指定文件资源，<code>resource</code>只能指定单个文件资源。</p>\n<h5 id=\"1-1-语法\">1.1 语法<a href=\"2019/12/17/iOS组件化-资源管理#1-1-语法\"></a></h5><pre><code>spec.resource = &apos;Resources/HockeySDK.bundle&apos;\nspec.resources = [&apos;Images/*.png&apos;, &apos;Sounds/*&apos;]</code></pre><h5 id=\"1-2-官方描述-Podspec语法官方介绍\">1.2 官方描述 <a href=\"https://guides.cocoapods.org/syntax/podspec.html#resources\" target=\"_blank\" rel=\"noopener\"><code>Podspec语法官方介绍</code></a><a href=\"2019/12/17/iOS组件化-资源管理#1-2-官方描述-Podspec语法官方介绍\"></a></h5><p><code>resources</code>将指定的资源复制到目标<code>bundle</code>，我们强烈建议开发者使用 <code>resource bundles</code>去构建静态资源库。使用<code>resources</code>属性仅仅是将指定的文件资源复制到目标<code>bundle</code>，如此<code>Xcode</code>不会对相关资源进行优化操作。</p>\n<p>看完官方描述，我们第一直觉就会放弃使用这种方式了。虽然如此，但是我们还是去看看如果使用这种方式具体会产生哪些影响。</p>\n<h5 id=\"1-3-resource探究\">1.3 <code>resource</code>探究<a href=\"2019/12/17/iOS组件化-资源管理#1-3-resource探究\"></a></h5><p>使用<code>pod lib create SCResource_Resources</code>命令创建项目。打开<code>Example</code>中的项目，并删除<code>SCResource_Resources.podspec</code>中无用的代码。如下图所示。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/2.png\" class=\"article-img\">\n\n<h6 id=\"1-3-1-resource不嵌入xcassets文件\">1.3.1 <code>resource</code>不嵌入<code>xcassets</code>文件<a href=\"2019/12/17/iOS组件化-资源管理#1-3-1-resource不嵌入xcassets文件\"></a></h6><p>选中<code>ReplaceMe.m</code>文件，右键<code>Show in Finder</code>,调至上一级文件夹，看到<code>Classes</code>和<code>Assets</code>文件夹。我们把<code>ReplaceMe.m</code>删除，并删除<code>SCResource_Resources.podspec</code>中的<code>s.source_files</code>,因为我们在资源组件中暂时不用编辑代码。然后把事先准备好的图片资源放入<code>Assets</code>文件夹下,并设置<code>resource</code>属性。最终如下图所示。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/3.png\" class=\"article-img\">\n\n<p>终端<code>pod install</code>后，便可以看到图片资源已经被加到<code>Resources</code>文件夹下。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/4.png\" class=\"article-img\">\n\n<h6 id=\"查看资源文件在包中的位置\">查看资源文件在包中的位置<a href=\"2019/12/17/iOS组件化-资源管理#查看资源文件在包中的位置\"></a></h6><p>真机运行，选择<code>Products</code>文件夹下的<code>SCResource_Resources_Example.app</code>右键<code>Show in Finder</code>,选中<code>SCResource_Resources_Example</code>右键，选择<code>显示包内容</code>，就可以看到我们添加的<code>Images</code>文件夹。查看并记录文件夹的大小。发现和事先我们准备的文件夹大小相同,均为21.5M。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/5.png\" class=\"article-img\">\n\n<h6 id=\"资源文件获取\">资源文件获取<a href=\"2019/12/17/iOS组件化-资源管理#资源文件获取\"></a></h6><p>一般情况下，我们在项目中获取图片都是通过使用<code>imageNamed:</code>方法去获取。那么现在我们把图片资源放在组件中，通过这样的方式也能够获取吗？</p>\n<p>我们在<code>Example</code>项目中的<code>SCViewController.m</code>的<code>viewDidLoad</code>方法中键入如下代码：</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/6.png\" class=\"article-img\">\n\n<p>前面我们查看过<code>Images</code>最终在APP中的路径，并且容易找到<code>goodluck_smile</code>图片的路径是<code>Images/好运墙/goodluck_smile</code>。运行项目，发现我们拿到的<code>image</code>对象是<code>nil</code>。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/7.png\" class=\"article-img\">\n\n<p>很糟糕，我们没有获取到对应的图片。查看注释可以知道<code>imageNamed:</code>是从<code>main bundle</code>中获取文件资源，那么如果我们把图片放在主工程中的<code>Images.xcassets</code>文件中，这里的文件在最终的包中的路径是什么呢？带着这样的疑问，我们简单地把一张图片(<code>goodluck_smile</code>)放入<code>Images.xcassets</code>中，真机运行后，通过上述<code>查看资源文件在包中的位置</code>的操作方法进行查看。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/8.png\" class=\"article-img\">\n\n<p>可以看到多出了<code>Assets.car</code>文件，由此可以知道，<code>Images.xcassets</code>中的图片资源，最终会被打包成<code>Assets.car</code>文件，也从侧面可以说明<code>Assets.car</code>文件所在的目录就是<code>main bundle</code>的路径，那么为什么组件中的图片没有被正常获取呢？难道是因为我们路径问题？</p>\n<p>前面我们已经说过<code>goodluck_smile</code>图片是在<code>Images/好运墙/</code> 下，那么我么手动拼接试试。为了排除其它影响，我们删除掉前面在<code>Images.xcassets</code>中的图片文件，并运行。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/9.png\" class=\"article-img\">\n\n<p>这时候，我们正确获取到了我们想要的图片。现在我们可以通过代码来获取到组件中的图片了，需要注意的点是需要传入图片的相对路径，那么在<code>xib</code>中又如何呢？</p>\n<p>我们再<code>Main.storyboard</code>中添加一个<code>UIImageView</code>,并直接设置<code>goodluck_smile</code>图片,瞬间就心情大好，因为立马就看到<code>Main.storyboard</code>显示了对应的图片。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/10.png\" class=\"article-img\">\n\n<p>真机运行，看看会不会有什么问题。</p>\n<p>运行后发现，我们设置的图片没有正常显示，那么也是因为我们要填写相对路径的原因吗？我们去试试。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/11.png\" class=\"article-img\">\n\n<p>这时候，发现<code>Main.storyboard</code>没有正常显示图片，但是真机运行后，图片显示正常。</p>\n<h6 id=\"总结：\">总结：<a href=\"2019/12/17/iOS组件化-资源管理#总结：\"></a></h6><p>使用<code>resource/resources</code>直接存放文件资源时，无论是通过代码获取图片，还是在<code>xib</code>中设置图片，都需要填写完整的相对路径。当然如果你想直接通过设置图片名称的方式获取图片，那么你必须将图片直接暴露在<code>resources</code>文件下，不能新建文件对相关资源做整理。</p>\n<h6 id=\"1-3-2-resource嵌入xcassets文件\">1.3.2 <code>resource</code>嵌入<code>xcassets</code>文件<a href=\"2019/12/17/iOS组件化-资源管理#1-3-2-resource嵌入xcassets文件\"></a></h6><p>在没有组件化时，我们一般把图片资源都放在<code>Images.xcassets</code>文件内管理，其为我们提供了许多优化点和一些方便的功能，所以我们可能也希望在组件中也利用这些优化和功能。那么在<code>resource</code>中如何通过<code>xcassets</code>来管理图片呢？其实很简单，只需在组件的<code>Assets</code>文件夹下创建<code>Asset Catalog</code>文件，再将图片资源拖入即可。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/12.png\" class=\"article-img\">\n\n<h5 id=\"这里需要注意的是-在创建Asset-Catalog文件后，其目录可能不在组件的Assets文件下，需要手动将其拖入至文件下。\">这里需要注意的是:在创建<code>Asset Catalog</code>文件后，其目录可能不在组件的<code>Assets</code>文件下，需要手动将其拖入至文件下。<a href=\"2019/12/17/iOS组件化-资源管理#这里需要注意的是-在创建Asset-Catalog文件后，其目录可能不在组件的Assets文件下，需要手动将其拖入至文件下。\"></a></h5><img src=\"/2019/12/17/iOS组件化-资源管理/13.png\" class=\"article-img\">\n\n<p><code>pod install</code>后，对项目进行编译，如果出现如下错误，则选择<code>File -&gt; Workspace Settings -&gt; Build System</code>的<code>New Build System(Default)</code>改为<code>Legacy Build System</code>即可。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/14.png\" class=\"article-img\">\n\n<p>使用上文提到的<code>查看资源文件在包中的位置</code>的方式查看文件资源，前面我们也提及到，<code>xcassets</code>文件最后打包进APP是会转成<code>Assets.car</code>文件的，我们找到该文件，并查看该文件的大小。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/15.png\" class=\"article-img\">\n\n<p>文件大小变成了69.1M，是原先21.5M的好几倍，这会大大增大包的大小。</p>\n<h6 id=\"资源文件获取-1\">资源文件获取<a href=\"2019/12/17/iOS组件化-资源管理#资源文件获取-1\"></a></h6><p>在查看资源文件路径后，我们发现，其路径和在主工程中的<code>Images.xcassets</code>在包中的路径相同，那么可以推测，正常使用相关方法应该可以获取到资源文件。</p>\n<p>同样在<code>ViewDidLoad</code>方法中键入一下代码，看能否正确获取图片资源。断点运行后，发现可正常获取。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/16.png\" class=\"article-img\">\n\n<p>使用<code>xib</code>方式也一样，这里就不再截图，大家可以自己尝试。</p>\n<h6 id=\"总结：-1\">总结：<a href=\"2019/12/17/iOS组件化-资源管理#总结：-1\"></a></h6><p><code>resource</code>嵌入<code>xcassets</code>文件时，资源文件会被<code>copy</code>至<code>main bundle</code>中，可以正常获取资源文件，但是会造成APP大小变大，因此不建议使用。</p>\n<h3 id=\"2-resource-bundle-resource-bundles\">2. <code>resource_bundle/resource_bundles</code><a href=\"2019/12/17/iOS组件化-资源管理#2-resource-bundle-resource-bundles\"></a></h3><p>和<code>resource/resources</code>类似，<code>resource_bundle/resource_bundles</code>功能相同，区别在与指定一个和多个。</p>\n<h5 id=\"2-1-语法\">2.1 语法<a href=\"2019/12/17/iOS组件化-资源管理#2-1-语法\"></a></h5><pre><code>spec.ios.resource_bundle = { &apos;MapBox&apos; =&gt; &apos;MapView/Map/Resources/*.png&apos; }\nspec.resource_bundles = {\n    &apos;MapBox&apos; =&gt; [&apos;MapView/Map/Resources/*.png&apos;],\n    &apos;MapBoxOtherResources&apos; =&gt; [&apos;MapView/Map/OtherResources/*.png&apos;]\n  }</code></pre><h5 id=\"2-2-官方描述-Podspec语法官方介绍\">2.2 官方描述 <a href=\"https://guides.cocoapods.org/syntax/podspec.html#resource_bundles\" target=\"_blank\" rel=\"noopener\"><code>Podspec语法官方介绍</code></a><a href=\"2019/12/17/iOS组件化-资源管理#2-2-官方描述-Podspec语法官方介绍\"></a></h5><p>重点翻译：强烈建议使用该方式为<code>Pod</code>构建静态库,文件资源通过键值匹配资源，<code>bundle</code>的名称应该包含<code>Pod</code>的名称来降低名称冲突的可能性。</p>\n<h5 id=\"2-3-resource-bundle探究\">2.3 <code>resource_bundle</code>探究<a href=\"2019/12/17/iOS组件化-资源管理#2-3-resource-bundle探究\"></a></h5><p>下面同样通过是否嵌入<code>xcassets</code>文件来分析这两种情况的优劣。</p>\n<h6 id=\"2-3-1-resource-bundle不嵌入xcassets文件\">2.3.1 <code>resource_bundle</code>不嵌入<code>xcassets</code>文件<a href=\"2019/12/17/iOS组件化-资源管理#2-3-1-resource-bundle不嵌入xcassets文件\"></a></h6><p>不嵌入<code>xcassets</code>文件时，和<code>resource</code>一样，直接将文件资源拖入至<code>Assets</code>文件夹下，具体参考上文<code>resource不嵌入xcasset文件</code>中的内容。然后修改<code>podspec</code>文件制定文件资源的方式，如下图所示。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/17.png\" class=\"article-img\">\n\n<p><code>pod install</code>，真机运行，<code>查看资源文件在包中的位置</code>,可以看到一个<code>SCResource_Resources.bundle</code>的文件。查看该文件的大小为21.1M，比原文件略小。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/18.png\" class=\"article-img\">\n\n<p>再选择<code>SCResource_Resources.bundle</code>右键<code>显示包内容</code>，可看到我们放进去的<code>Images</code>图片文件夹。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/19.png\" class=\"article-img\">\n\n<h6 id=\"资源文件获取-2\">资源文件获取<a href=\"2019/12/17/iOS组件化-资源管理#资源文件获取-2\"></a></h6><p>前面在<code>resource</code>的章节中，我们已经知道需要通过拼接资源的相对路径才能获取相应的资源，所以我们这里也尝试看看会发生什么。</p>\n<p>在<code>ViewDidLoad</code>方法中键入下面代码：</p>\n<pre><code>UIImage *image = [UIImage imageNamed:@&quot;SCResource_Resources.bundle/Images/好运墙/goodluck_smile&quot;];</code></pre><p>断点查看是否能正常获取图片资源。</p>\n<p>在<code>xib</code>中同样这样拼接，真机运行，看能否正常显示图片。</p>\n{% asset_img 20.png %}\n\n\n<p>运行后，我们可以如预期一样获取资源文件。</p>\n{% asset_img 21.png %}\n\n<h6 id=\"总结：-2\">总结：<a href=\"2019/12/17/iOS组件化-资源管理#总结：-2\"></a></h6><p><code>resource_bundle</code>不嵌入<code>xcasset</code>文件，需拼接文件的相对路径才能正确获取图片资源。</p>\n<h6 id=\"2-3-2-resource-bundle嵌入xcassets文件\">2.3.2 <code>resource_bundle</code>嵌入<code>xcassets</code>文件<a href=\"2019/12/17/iOS组件化-资源管理#2-3-2-resource-bundle嵌入xcassets文件\"></a></h6><p>嵌入<code>xcassets</code>文件时，也和<code>resource</code>一样，创建<code>xcassets</code>文件，拖入文件资源，并拖入至<code>Assets</code>文件夹下，具体参考上文<code>resource嵌入xcasset文件</code>中的内容。</p>\n<p><code>pod install</code>并真机运行,<code>查看资源文件在包中的位置</code>,我们同样可以看到<code>SCResource_Resources.bundle</code>文件，查看文件大小，可以看到只有16.8M，比前面所有情况都要小。</p>\n{% asset_img 22.png %}\n\n<p>再选择<code>SCResource_Resources.bundle</code>右键<code>显示包内容</code>，可看到我们放进去的<code>Assets.car</code>文件。与前文的情况一致。</p>\n<h6 id=\"资源文件获取-3\">资源文件获取<a href=\"2019/12/17/iOS组件化-资源管理#资源文件获取-3\"></a></h6><p>在<code>resource</code>的章节中，如果嵌套<code>xcassets</code>文件，我们可以直接通过图片名称来获取文件资源，那么这里是不是类似呢，我们来试试。</p>\n<p>在<code>viewDidLoad</code>方法中键入下面代码:</p>\n<pre><code>UIImage *image = [UIImage imageNamed:@&quot;goodluck_smile&quot;];</code></pre><p>运行，查看<code>image</code>对象是否存在。</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/23.png\" class=\"article-img\">\n\n<p>很遗憾，结果为<code>nil</code>。那么我们拼接路径呢？同样在<code>viewDidLoad</code>方法中键入下面代码:</p>\n<pre><code>UIImage *image = [UIImage imageNamed:@&quot;SCResource_Resources.bundle/goodluck_smile&quot;];</code></pre><p>运行，查看<code>image</code>对象是否存在。</p>\n{% asset_img 24.png %}\n\n<p>同样的结果，还是<code>nil</code>。</p>\n<p>使用这种方式，我们需要换一个方法去获取指定资源，我们需要调用<code>UIImage</code>的<code>imageNamed:inBundle: compatibleWithTraitCollection:</code>方法。指定bundle和图片的名称即可。</p>\n<pre><code>NSString *bundleName = @&quot;SCResource_Resources&quot;;\nNSString *imageBundlePath = [[NSBundle mainBundle] pathForResource:bundleName ofType:@&quot;bundle&quot;];\nNSBundle *imageBundle = [NSBundle bundleWithPath:imageBundlePath];\n\nUIImage *image = [UIImage imageNamed:@&quot;goodluck_smile&quot; inBundle:imageBundle compatibleWithTraitCollection:nil];</code></pre><p>运行，查看<code>image</code>对象是否存在</p>\n<img src=\"/2019/12/17/iOS组件化-资源管理/25.png\" class=\"article-img\">\n\n<p>运行结果如预期，可获取对应文件资源。</p>\n<p>在<code>xib</code>中如何设置呢?可以添加分类暴露<code>bundleName</code>和<code>imageName</code>使用<code>IBInspectable</code>修饰，调用<code>imageNamed:inBundle: compatibleWithTraitCollection:</code>方法。</p>\n<h6 id=\"总结：-3\">总结：<a href=\"2019/12/17/iOS组件化-资源管理#总结：-3\"></a></h6><p><code>resource_bundle</code>嵌入<code>xcasset</code>文件，包文件大小相对于其它情况较小，但获取文件资源时，需要封装方法调用<code>UIImage</code>的<code>imageNamed:inBundle: compatibleWithTraitCollection:</code>方法。</p>\n<h3 id=\"总结\">总结<a href=\"2019/12/17/iOS组件化-资源管理#总结\"></a></h3><p>使用<code>CocoaPods</code>方式组件化，对文件资源进行管理，建议使用<code>resource_bundle/resource_bundles</code>嵌入<code>xcassets</code>文件的方式。这样一来可以使用<code>xcassets</code>的一些特性和优化，也能够在一定程度上减小包的体积。</p>\n","next":{"title":"Xcode10以及Xcode11缺少libstdc-6dylib报错的解决方案","link":"2019/12/03/Xcode10以及Xcode11缺少libstdc-6dylib报错的解决方案"},"plink":"http://yoursite.com/2019/12/17/iOS组件化-资源管理/"}