{"title":"读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录","date":"2019-12-03T07:33:08.524Z","link":"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录","comments":true,"updated":"2019-12-03T08:50:54.064Z","content":"<h3 id=\"相关基础知识简介\">相关基础知识简介<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#相关基础知识简介\"></a></h3><h4 id=\"A-函数指针\">A. 函数指针<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#A-函数指针\"></a></h4><h5 id=\"1-函数指针：存储函数地址的指针变量。\">1. 函数指针：存储函数地址的指针变量。<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#1-函数指针：存储函数地址的指针变量。\"></a></h5><h5 id=\"2-函数指针的定义：\">2. 函数指针的定义：<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#2-函数指针的定义：\"></a></h5><p><code>函数返回值类型 (* 指针变量名)(函数参数列表)</code></p>\n<h5 id=\"3-函数指针的简单使用：\">3. 函数指针的简单使用：<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-函数指针的简单使用：\"></a></h5><pre><code>int max(int a, int b);\n\nint main(int argc, const char * argv[]) {\n    // 定义函数指针\n    int (*maxPtr)(int, int) = max;\n    // 通过函数指针调用函数\n    printf(&quot;%d\\n&quot;, maxPtr(3, 5));\n\n    return 0;\n}\n\nint max(int a, int b) {\n    return a &gt; b ? a : b;\n}</code></pre><h4 id=\"B-结构体\">B. 结构体<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#B-结构体\"></a></h4><h5 id=\"1-结构体的定义\">1. 结构体的定义:<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#1-结构体的定义\"></a></h5><pre><code>struct 结构体名 {\n    结构体成员\n};</code></pre><h5 id=\"2-结构体变量\">2. 结构体变量:<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#2-结构体变量\"></a></h5><pre><code>struct Student {\n    char *name;\n    int num;\n    int age;\n    float score;\n} student1, student2;</code></pre><h5 id=\"3-成员赋值\">3.    成员赋值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-成员赋值\"></a></h5><h6 id=\"3-1-对成员进行逐一赋值\">3.1 对成员进行逐一赋值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-1-对成员进行逐一赋值\"></a></h6><pre><code>student1.name = &quot;Tom&quot;\nstudent1.num = 12;\nstudent1.age = 16;\nstudent.score = 98.5;\n\nstudent2.name = &quot;jerry&quot;\nstudent2.num = 13;\nstudent2.age = 16;\nstudent2.score = 99;</code></pre><h6 id=\"3-2-定义时整体赋值\">3.2 定义时整体赋值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-2-定义时整体赋值\"></a></h6><pre><code>struct Student {\n    char *name;\n    int num;\n    int age;\n    float score;\n} student1 = {&quot;tom&quot;, 12, 16, 98.5};</code></pre><h6 id=\"3-3-C-中的构造函数之一\">3.3 C++中的构造函数之一:<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-3-C-中的构造函数之一\"></a></h6><pre><code>struct Student {\n    char *name;\n    int num;\n    int age;\n    float score;\n    Student(char *_name, int _num, int _age, float _score) : name(_name), num(_num), age(_age), score(_score) {\n\n    }\n};</code></pre><h6 id=\"3-4-结构体变量创建和访问对象：\">3.4 结构体变量创建和访问对象：<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-4-结构体变量创建和访问对象：\"></a></h6><pre><code>Student s1 = Student(&quot;Tom&quot;, 12, 16, 95.0);\nstd::cout &lt;&lt; s1.name &lt;&lt; &quot;\\n&quot; &lt;&lt; s1.num &lt;&lt; &quot;\\n&quot; &lt;&lt; s1.age &lt;&lt; &quot;\\n&quot; &lt;&lt; s1.score &lt;&lt; std::endl;</code></pre><h4 id=\"C-结构体指针\">C. 结构体指针<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#C-结构体指针\"></a></h4><h5 id=\"1-定义-指向结构体的指针\">1. 定义:指向结构体的指针<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#1-定义-指向结构体的指针\"></a></h5><h5 id=\"2-定义形式\">2. 定义形式:<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#2-定义形式\"></a></h5><p><code>struct 结构体名 *变量名</code></p>\n<h5 id=\"3-简单使用\">3. 简单使用:<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-简单使用\"></a></h5><pre><code>struct Student {\n   char *name;\n   int num;\n   int age;\n   float score;\n   Student(char *_name, int _num, int _age, float _score) : name(_name), num(_num), age(_age), score(_score) {\n\n   }\n };\n\nStudent s1 = Student(&quot;Tom&quot;, 12, 16, 98.5);\nstruct Student *studentPtr = &amp;s1;\nstd::cout &lt;&lt; (*studentPtr).name &lt;&lt; std::endl;\nstd::cout &lt;&lt; (*studentPtr).num &lt;&lt; std::endl;\nstd::cout &lt;&lt; (*studentPtr).age &lt;&lt; std::endl;\nstd::cout &lt;&lt; (*studentPtr).score &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; &quot;-------------------&quot; &lt;&lt; std::endl;\n\nstd::cout &lt;&lt; studentPtr -&gt; name &lt;&lt; std::endl;\nstd::cout &lt;&lt; studentPtr -&gt; num &lt;&lt; std::endl;\nstd::cout &lt;&lt; studentPtr -&gt; age &lt;&lt; std::endl;\nstd::cout &lt;&lt; studentPtr -&gt; score &lt;&lt; std::endl;</code></pre><h3 id=\"Blocks基本用法简介：\">Blocks基本用法简介：<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#Blocks基本用法简介：\"></a></h3><h4 id=\"A-什么是Blocks：\">A. 什么是Blocks：<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#A-什么是Blocks：\"></a></h4><p>Blocks是带有自动变量（局部变量）的匿名函数</p>\n<h4 id=\"B-Block语法\">B. Block语法<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#B-Block语法\"></a></h4><p><code>^ 返回值类型 参数列表 表达式</code></p>\n<p>例如：</p>\n<pre><code>^void(int a) {\n    printf(&quot;%d&quot;, a);\n}</code></pre><h5 id=\"1-省略形式-省略返回值类型\">1. 省略形式:省略返回值类型<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#1-省略形式-省略返回值类型\"></a></h5><pre><code>`^参数列表 表达式`\n\n    ^(int a) {\n        printf(&quot;%d&quot;, a);\n    }\n\n省略返回值类型时，当表达式中无return语句，那么省略的返回值类型是void，如果表达式中有return语句，那么省略的返回值类型为return语句返回的类型，如果表达式中有多个return语句，那么必须保证所有return语句的返回值类型都相同。</code></pre><h5 id=\"2-省略形式：省略返回值类型和参数列表\">2. 省略形式：省略返回值类型和参数列表<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#2-省略形式：省略返回值类型和参数列表\"></a></h5><pre><code>`^表达式`\n\n如果不使用参数，那么可以将参数列表省略，例如：\n\n    ^void(void) {\n        printf(&quot;Block\\n&quot;);\n    }\n\n省略调返回值和参数列表后，代码如下：\n\n    ^{\n        printf(&quot;Block\\n&quot;);\n    }</code></pre><h4 id=\"C-Block类型变量\">C. Block类型变量<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#C-Block类型变量\"></a></h4><h5 id=\"1-声明Block类型变量：\">1. 声明Block类型变量：<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#1-声明Block类型变量：\"></a></h5><pre><code>`返回值类型 (^变量名称) (参数列表)`\n\n例如：\n\n    int (^blk)(int);</code></pre><h5 id=\"2-C语言函数声明、函数指针声明、Block类型变量声明类比\">2. C语言函数声明、函数指针声明、Block类型变量声明类比:<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#2-C语言函数声明、函数指针声明、Block类型变量声明类比\"></a></h5><p>|  C语言函数声明   | C语言函数指针声明  | Block变量声明 |<br>|  :—-:  | :—-:  | :—-: | :—-: |<br>| <code>返回值类型 函数名 参数列表</code>  | <code>返回值类型 (*指针变量名) 参数列表</code> | <code>返回值类型 (^block变量名) 参数列表</code>  |</p>\n<h5 id=\"3-赋值\">3.赋值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#3-赋值\"></a></h5><pre><code>int (^blk)(int) = ^(int count) {\n    return count++;\n};</code></pre><h5 id=\"4-作为函数的参数\">4.作为函数的参数<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#4-作为函数的参数\"></a></h5><pre><code>void func(int (^blk)(int)) {\n\n}</code></pre><h5 id=\"5-作为函数的返回值\">5.作为函数的返回值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#5-作为函数的返回值\"></a></h5><pre><code>int(^func()(int)) {\n    return ^(int count) {\n        return count++;\n    };\n}</code></pre><h5 id=\"6-使用typedef简化写法\">6.使用<code>typedef</code>简化写法<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#6-使用typedef简化写法\"></a></h5><p><code>typedef int (^blk_t)(int)</code></p>\n<h6 id=\"6-1-作为函数的参数\">6.1 作为函数的参数<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#6-1-作为函数的参数\"></a></h6><pre><code>void func(blk_t blk) {\n\n}</code></pre><h6 id=\"6-2-作为函数的返回值\">6.2 作为函数的返回值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#6-2-作为函数的返回值\"></a></h6><pre><code>blk_t func() {\n\n}</code></pre><h5 id=\"7-调用Block变量\">7. 调用<code>Block</code>变量<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#7-调用Block变量\"></a></h5><pre><code>int(^blk)(int) = ^(int count) {\n    return count++;\n};\n\nint result =  blk(10);</code></pre><h4 id=\"D-block说明符在block中修改自动变量\">D. <code>__block</code>说明符在block中修改自动变量<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#D-block说明符在block中修改自动变量\"></a></h4><pre><code>__block int val = 10;\nvoid(^blk)(void) = ^{\n    val++;\n};\n\nblk();\nprintf(&quot;val:%d, val&quot;);</code></pre><h3 id=\"Blocks的实现\">Blocks的实现<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#Blocks的实现\"></a></h3><p>通过<code>clang(LLVM编译器)</code>将<code>Block</code>代码转换为<code>C++</code>源代码。打开终端，进入到对应的文件位置，使用下面命令，将代码转换成<code>C++</code>源代码。</p>\n<p><code>clang -rewrite-objc 源代码文件名</code></p>\n<p>执行命令后，可在当前目录下找到对应文件名的<code>.cpp</code>文件,该文件的源码即为转换后的源码。打开对应文件阅读。</p>\n<p>例如，xCode新建项目，选择<code>macOS</code>,再选择<code>Command Line Tool</code>。如图所示。</p>\n<img src=\"/2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录/1.png\" class=\"article-img\">\n<p>完成项目创建后，键入最简单的关于<code>Blocks</code>的代码，如下。</p>\n<pre><code>int main(int argc, const char * argv[]) {\n\n    void(^blk)(void) = ^{\n        printf(&quot;Blocks\\n&quot;);\n    };\n\n    blk();\n\n    return 0;\n}</code></pre><p>打开终端，进入到对应文件，执行上述命令。可得到对应<code>.cpp</code>文件如图所示。</p>\n<img src=\"/2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录/2.png\" class=\"article-img\">\n\n<p>打开<code>main.cpp</code>文件,可以看到，我们这项目中写的几行代码，瞬间变成了上万行代码。</p>\n<img src=\"/2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录/3.png\" class=\"article-img\">\n\n<p>我们将代码进行整理，只有下面这些代码是我们需要的，其它的大部分都是因为<code>import</code>对应的库而产生的代码。所以我们将有用的代码列举出来如下。</p>\n<pre><code>struct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n    printf(&quot;Blocks\\n&quot;);\n}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n\n    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));\n\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n\n    return 0;\n}</code></pre><p>接下来我们对照源码进行相关解析。通过对比我们手写的<code>block</code>代码，</p>\n<pre><code>void(^blk)(void) = ^{\n   printf(&quot;Blocks\\n&quot;);\n};</code></pre><p>我们可以很容易找到转换后的对应的函数。</p>\n<pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\n    printf(&quot;Blocks\\n&quot;);\n}</code></pre><p>我们可以发现，转换后的函数有一个<code>__cself</code>的结构体指针（有关于结构体指针的相关知识，可以查看前文的简介或自行查阅相关资料）。<code>__cself</code>结构体指针，其实类似于<code>self</code>以及<code>C++</code>中的<code>this</code>指针。<code>__cself</code>为指向<code>Block</code>值的变量。既然<code>__cself</code>是结构体指针，那么我们来看下<code>__cself</code>对应的结构体<code>__main_block_impl_0</code>。</p>\n<pre><code>struct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};</code></pre><p>从<code>__main_block_impl_0</code>结构体的声明中可以看到，该结构体拥有两个成员变量<code>impl</code>、<code>Desc</code>以及构造函数。<br>首先我们看下成员变量<code>impl</code>, 其是<code>__block_impl</code>类型的结构体，该结构体的声明如下。</p>\n<pre><code>struct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};</code></pre><p>从结构体声明中可以看到很熟悉的一些标记位，例如<code>isa</code>、<code>Flags</code>以及<code>Reserved</code>以及函数指针<code>FuncPtr</code>。</p>\n<p>第二个成员变量<code>Desc</code>,这是一个结构体指针，同样我们找到对应的结构体来查看。</p>\n<pre><code>static struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};</code></pre><p>该结构体比较简单，只包含两个成员<code>reserved</code>标记位以及<code>Block_size</code>，从其对结构体的赋值来看，<code>Block_size</code>存储的是<code>__main_block_impl_0</code>结构体的大小。</p>\n<p>最后回到<code>__main_block_impl_0</code>结构体的构造函数。</p>\n<pre><code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n }</code></pre><p>该构造函数对<code>impl</code>结构体的成员变量和<code>Desc</code>结构体指针进行初始化。</p>\n<p>再找到<code>main</code>函数的转换后的函数。</p>\n<pre><code>int main(int argc, const char * argv[]) {\n\n    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));\n\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n\n    return 0;\n}</code></pre><p>观察main函数中的第一行代码：</p>\n<pre><code>void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</code></pre><p>首先我们看<code>=</code>的右半部分。</p>\n<pre><code>((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA))</code></pre><p>去掉对应的类型转换代码后代码如下：</p>\n<pre><code>&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA))</code></pre><p>这样就比较清晰地看出，这是通过取地址符<code>&amp;</code>获取<code>__main_block_impl_0</code>结构体示例的指针，即<code>__main_block_impl_0</code>结构体指针。所以<code>=</code>左端的实际类型应该是<code>__main_block_impl_0</code>结构体指针，所以可以将该代码转换成下面代码：</p>\n<pre><code>struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));\nstruct __main_block_impl_0 *blk = &amp;temp;</code></pre><p>在初始化<code>_main_block_impl_0</code>结构体变量时，将函数<code>__main_block_func_0</code>的首地址作为参数传入，将其赋值给<code>impl</code>的<code>FuncPtr</code>。</p>\n<p>继续看<code>Block</code>的调用和转换后的代码。</p>\n<pre><code>((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</code></pre><p>同样去掉类型转换后，我们可以清楚地看出其实际操作如下：</p>\n<pre><code>(*blk-&gt;impl.FuncPtr)(blk);</code></pre><p>即简单的使用函数指针调用函数，也可以很明显看出将<code>Block本身blk</code>传入<code>__main_block_func_0</code>方法，即<code>__cself</code>指向<code>block</code>本身。<br>再次回到<code>__main_block_impl_0</code>结构体，在结构体中的<code>impl</code>成员中，我们看到<code>isa</code>指针，此时，我们很容易联想到<code>Objective-C</code>的类与对象。三者之间其实是类似的，因此，<code>Block</code>其实就是<code>Objective-C</code>对象。</p>\n<h3 id=\"截获自动变量值\">截获自动变量值<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#截获自动变量值\"></a></h3><p>我们都清楚，<code>Blocks</code>是可以截获自动变量值的，那么<code>Blocks</code>具体是如何截获自动变量值的。我们同样通过<code>clang</code>命令来转化相关<code>Objective-C</code>代码。</p>\n<p>在项目中，我们重新键入如下代码：</p>\n<pre><code>int main(int argc, const char * argv[]) {\n\n    int val = 10;\n    const char *fmt = &quot;val = %d\\n&quot;;\n    void(^blk)(void) = ^{\n        printf(fmt, val);\n    };\n\n    val = 2;\n    fmt = &quot;These values were changed. val = %d\\n&quot;;\n\n    blk();\n\n    return 0;\n}</code></pre><p>同样，我们使用上文提及的<code>clang</code>命令，将源码进行转换。略去不必要的内容，获得我们所需的代码片段如下。</p>\n<pre><code>struct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  const char *fmt;\n  int val;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  const char *fmt = __cself-&gt;fmt; // bound by copy\n  int val = __cself-&gt;val; // bound by copy\n\n        printf(fmt, val);\n  }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n\n    int val = 10;\n    const char *fmt = &quot;val = %d\\n&quot;;\n    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));\n\n    val = 2;\n    fmt = &quot;These values were changed. val = %d\\n&quot;;\n\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n\n    return 0;\n}</code></pre><p>与前段代码转换后的代码进行比较，很容易发现两者之间的差异。</p>\n<p><code>__main_block_impl_0</code>结构体，多了一些成员，这些成员正好是<code>Block</code>语法中使用到的变量。并且其构造函数，也多了对应的参数，用于初始化在<code>Block</code>中使用的变量。由此可知，在<code>__main_block_impl_0</code>结构体实例中，自动变量值被截获。</p>\n<p><code>__main_block_func_0</code>方法中，在前一节的代码中，没有使用指向<code>Block</code>本身的<code>__cself</code>，在该段代码中清晰地看到，使用被截获的自动变量的值，即<code>Block</code>本身(<code>__main_block_impl_0</code>结构体实例)成员变量的值。</p>\n<p>因此，所谓”截获自动变量的值”，意味着在执行<code>Block</code>语法时，<code>Block</code>语法表达式所使用的自动变量的值被保存到<code>Block</code>的结构体实例中。</p>\n<h3 id=\"block说明符\">__block说明符<a href=\"2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录#block说明符\"></a></h3><p>在前文介绍过，如果需要再<code>Block</code>语法中改变自动变量的值，那么需要在自动变量前加上<code>__block</code>进行修饰，否则会报错，那么除了这种常用方式外，还有其它的方式来改变被截获的自动变量的值吗？答案是有的。我们可以声明如下变量：</p>\n<ol>\n<li>静态变量</li>\n<li>静态全局变量</li>\n<li>全局变量</li>\n</ol>\n<p>可以用一下代码进行验证：</p>\n<pre><code>int global_val = 1;\nstatic int static_global_val = 2;\n\nint main(int argc, const char * argv[]) {\n\n    static int static_val = 3;\n\n    void(^blk)(void) = ^{\n        global_val *= 2;\n        static_global_val *= 3;\n        static_val *= 4;\n    };\n\n    blk();\n\n    printf(&quot;%d--%d--%d\\n&quot;, global_val, static_global_val, static_val);\n\n    return 0;\n}</code></pre><p>打印出来的结果是<code>2--6--12</code>,完全符合我们的预期，那么这些代码转换成<code>C++</code>代码又是怎么样的呢?还是使用<code>clang</code>命令进行转换。</p>\n<pre><code>int global_val = 1;\nstatic int static_global_val = 2;\n\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int *static_val;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0) : static_val(_static_val) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int *static_val = __cself-&gt;static_val; // bound by copy\n\n        global_val *= 2;\n        static_global_val *= 3;\n        (*static_val) *= 4;\n    }\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main(int argc, const char * argv[]) {\n\n    static int static_val = 3;\n\n    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));\n\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n\n    printf(&quot;%d--%d--%d\\n&quot;, global_val, static_global_val, static_val);\n\n    return 0;\n}</code></pre><p>我们查看转换后的函数。</p>\n<pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int *static_val = __cself-&gt;static_val; // bound by copy\n\n        global_val *= 2;\n        static_global_val *= 3;\n        (*static_val) *= 4;\n    }</code></pre><p>对静态全局变量和全局变量的访问与转换前相同，但是静态变量<code>static_val</code>是在初始化结构体<code>__main_block_impl_0</code>时，将<code>static_val</code>的地址传入构造函数进行初始化，最后通过地址进行访问修改.</p>\n<pre><code>struct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int *static_val;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0) : static_val(_static_val) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};</code></pre><p>使用静态变量的方法似乎也可以适用于自动变量的访问，但实际上，在<code>Block</code>语法生成的值<code>Block</code>上，可以存有超过其变量作用域的被截获对象的自动变量，变量作用域结束的同时，原来的自动变量被废弃，因此<code>Block</code>中超过变量作用域而存在的变量同静态变量一样，将不能通过指针访问原来的自动变量。</p>\n<p>使用<code>__block</code>来解决<code>Block</code>不能保存值这一问题。修改代码如下：</p>\n<pre><code>int main(int argc, const char * argv[]) {\n\n    __block int val = 10;\n\n    void(^blk)(void) = ^{\n        val = 1;\n    };\n\n    blk();\n\n    printf(&quot;%d\\n&quot;, val);\n\n    return 0;\n}</code></pre><p>对源码进行<code>clang</code>。获得关键代码，内容如下：</p>\n<pre><code>struct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\nstruct __Block_byref_val_0 {\n  void *__isa;\n__Block_byref_val_0 *__forwarding;\n int __flags;\n int __size;\n int val;\n};\n\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_val_0 *val; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) {\n    impl.isa = &amp;_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref\n\n        (val-&gt;__forwarding-&gt;val) = 1;\n    }\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\nint main(int argc, const char * argv[]) {\n\n    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10};\n\n    void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344));\n\n    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);\n\n    printf(&quot;%d\\n&quot;, (val.__forwarding-&gt;val));\n\n    return 0;\n}</code></pre><p>一眼望去，多了个前面未曾见过的结构体<code>__Block_byref_val_0</code></p>\n","prev":{"title":"工作问题汇总","link":"2019/12/03/工作问题汇总"},"plink":"http://yoursite.com/2019/12/03/读《Objective-C高级编程-iOS与OS-X多线程和内存管理》之Blocks总结记录/"}